<!doctype html>
<html lang="id">
<head>
  <meta charset="utf-8" />
  <title>Excel → My Maps (Preview + CSV/KML)</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <!-- SheetJS (XLSX) -->
  <script src="https://cdn.jsdelivr.net/npm/xlsx/dist/xlsx.full.min.js"></script>
  <!-- Leaflet for preview map -->
  <link rel="stylesheet" href="https://unpkg.com/leaflet/dist/leaflet.css"/>
  <script src="https://unpkg.com/leaflet/dist/leaflet.js"></script>
  <style>
    body { font-family: Arial, sans-serif; margin: 10px; }
    #map { height: 500px; border: 1px solid #ccc; margin-top:10px; }
    .controls { display:flex; gap:10px; flex-wrap:wrap; }
    .info { margin-top:8px; color:#333; font-size:0.95rem; }
    table { border-collapse: collapse; margin-top:10px; max-width:100%; overflow:auto; display:block;}
    table th, table td { border:1px solid #ddd; padding:6px 8px; font-size:0.9rem; }
    button { padding:8px 12px; }
  </style>
</head>
<body>
  <h1>Excel → My Maps (Preview • CSV • KML)</h1>

  <div class="controls">
    <input id="fileInput" type="file" accept=".xlsx,.xls,.csv" />
    <button id="btnParse">Parse & Tampilkan</button>
    <button id="btnDownloadCSV" disabled>Download CSV untuk My Maps</button>
    <button id="btnDownloadKML" disabled>Download KML</button>
    <label style="align-self:center;">
      <input id="chkHasLatLon" type="checkbox" /> File sudah berisi kolom lat/lon
    </label>
  </div>

  <div class="info">
    Petunjuk singkat: Jika file Anda memiliki kolom `lat` & `lon` (atau `latitude`/`longitude`) centang kotak "File sudah berisi kolom lat/lon".  
    Jika tidak, pastikan kolom alamat bernama `address`, atau `alamat`, atau gabungkan kolom `street`, `city`, `province`, `country` menjadi satu kolom alamat sebelum upload.
  </div>

  <div id="map"></div>

  <div id="tableContainer"></div>

<script>
/*
  Excel → MyMaps helper (client-side)
  - Membaca XLSX/CSV via SheetJS
  - Jika ada lat/lon, gunakan itu; jika tidak, geocode via Nominatim (OpenStreetMap) (rate-limited)
  - Menampilkan marker di Leaflet map
  - Menyediakan download CSV & KML yang bisa di-import ke Google My Maps
*/

const fileInput = document.getElementById('fileInput');
const btnParse = document.getElementById('btnParse');
const btnCSV = document.getElementById('btnDownloadCSV');
const btnKML = document.getElementById('btnDownloadKML');
const chkHasLatLon = document.getElementById('chkHasLatLon');
const tableContainer = document.getElementById('tableContainer');

let map = L.map('map').setView([-6.2, 106.8], 5); // center Indonesia
L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
  attribution: '© OpenStreetMap contributors'
}).addTo(map);
let markersLayer = L.layerGroup().addTo(map);

let parsedRows = []; // array of objects with at least {lat, lon, ...}

function showError(msg) {
  alert(msg);
}

function readFile(file) {
  return new Promise((resolve, reject) => {
    const reader = new FileReader();
    const name = file.name.toLowerCase();
    if (name.endsWith('.csv')) {
      reader.onload = (e) => resolve({data: e.target.result, type: 'csv'});
      reader.readAsText(file);
    } else {
      reader.onload = (e) => {
        const data = new Uint8Array(e.target.result);
        resolve({data, type: 'xlsx'});
      };
      reader.readAsArrayBuffer(file);
    }
  });
}

function parseExcel(content) {
  let wb;
  if (content.type === 'csv') {
    wb = XLSX.read(content.data, {type: 'string'});
  } else {
    wb = XLSX.read(content.data, {type: 'array'});
  }
  const firstSheetName = wb.SheetNames[0];
  const ws = wb.Sheets[firstSheetName];
  const json = XLSX.utils.sheet_to_json(ws, {defval: ''});
  return json;
}

async function geocodeAddress(address) {
  // Using Nominatim (OpenStreetMap). Respect rate limit (1 request per second recommended).
  // For production/high volume, use Google Geocoding API with an API key.
  const q = encodeURIComponent(address);
  const url = `https://nominatim.openstreetmap.org/search?format=json&q=${q}&limit=1`;
  try {
    const resp = await fetch(url, {
      headers: {
        'Accept': 'application/json',
        'User-Agent': 'Excel-To-MyMaps-Script/1.0 (your-email@example.com)' // replace with contact if heavy use
      }
    });
    if (!resp.ok) return null;
    const arr = await resp.json();
    if (arr && arr.length>0) {
      return { lat: parseFloat(arr[0].lat), lon: parseFloat(arr[0].lon) };
    }
    return null;
  } catch(e) {
    console.error('Geocode error', e);
    return null;
  }
}

function displayTable(rows) {
  tableContainer.innerHTML = '';
  if (!rows.length) return;
  const keys = Object.keys(rows[0]);
  const table = document.createElement('table');
  const thead = document.createElement('thead');
  const trh = document.createElement('tr');
  keys.forEach(k => { const th = document.createElement('th'); th.textContent = k; trh.appendChild(th); });
  thead.appendChild(trh);
  table.appendChild(thead);
  const tbody = document.createElement('tbody');
  rows.forEach(r => {
    const tr = document.createElement('tr');
    keys.forEach(k => {
      const td = document.createElement('td');
      td.textContent = (r[k] === undefined || r[k] === null) ? '' : r[k];
      tr.appendChild(td);
    });
    tbody.appendChild(tr);
  });
  table.appendChild(tbody);
  tableContainer.appendChild(table);
}

function clearMarkers() {
  markersLayer.clearLayers();
}

function addMarkers(rows) {
  clearMarkers();
  rows.forEach(r => {
    if (!isFinite(parseFloat(r.lat)) || !isFinite(parseFloat(r.lon))) return;
    const lat = parseFloat(r.lat), lon = parseFloat(r.lon);
    const popupContent = Object.keys(r).map(k => `<strong>${k}</strong>: ${r[k]}`).join('<br>');
    L.marker([lat, lon]).bindPopup(popupContent).addTo(markersLayer);
  });
  if (rows.length) {
    const valid = rows.filter(r => isFinite(parseFloat(r.lat)) && isFinite(parseFloat(r.lon)));
    if (valid.length) {
      const group = valid.map(r => [parseFloat(r.lat), parseFloat(r.lon)]);
      map.fitBounds(group);
    }
  }
}

function downloadFile(filename, content, mime) {
  const blob = new Blob([content], {type: mime || 'application/octet-stream'});
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url;
  a.download = filename;
  document.body.appendChild(a);
  a.click();
  a.remove();
  URL.revokeObjectURL(url);
}

function convertToCSV(rows) {
  if (!rows.length) return '';
  const keys = Object.keys(rows[0]);
  const lines = [];
  lines.push(keys.map(k => `"${String(k).replace(/"/g,'""')}"`).join(','));
  rows.forEach(r => {
    const line = keys.map(k => {
      const v = r[k] === undefined || r[k] === null ? '' : String(r[k]);
      return `"${v.replace(/"/g,'""')}"`;
    }).join(',');
    lines.push(line);
  });
  return lines.join('\n');
}

function convertToKML(rows, name='My Map Export') {
  const placemarks = rows.map(r => {
    if (!isFinite(parseFloat(r.lon)) || !isFinite(parseFloat(r.lat))) return '';
    const lon = r.lon, lat = r.lat;
    const fields = Object.keys(r).filter(k => k!=='lat' && k!=='lon').map(k => `<strong>${escapeXml(k)}:</strong> ${escapeXml(String(r[k]))}`).join('<br/>');
    return `
      <Placemark>
        <name>${escapeXml(r.name || r.label || '')}</name>
        <description><![CDATA[${fields}]]></description>
        <Point><coordinates>${lon},${lat},0</coordinates></Point>
      </Placemark>`;
  }).join('\n');
  return `<?xml version="1.0" encoding="UTF-8"?>
  <kml xmlns="http://www.opengis.net/kml/2.2">
  <Document>
    <name>${escapeXml(name)}</name>
    ${placemarks}
  </Document>
  </kml>`;
}

function escapeXml(s) {
  return s.replace(/[<>&'"]/g, function (c) {
    switch (c) {
      case '<': return '&lt;';
      case '>': return '&gt;';
      case '&': return '&amp;';
      case "'": return '&apos;';
      case '"': return '&quot;';
    }
  });
}

btnParse.addEventListener('click', async () => {
  const file = fileInput.files[0];
  if (!file) return showError('Pilih file Excel (.xlsx/.xls/.csv) terlebih dahulu.');
  btnParse.disabled = true;
  btnParse.textContent = 'Memproses…';
  try {
    const raw = await readFile(file);
    const json = parseExcel(raw);
    if (!json || !json.length) {
      showError('File tidak memiliki data yang dapat dibaca.');
      return;
    }
    // Normalize keys (lowercase trimmed)
    const rows = json.map(row => {
      const r = {};
      Object.keys(row).forEach(k => {
        const kk = String(k).trim();
        r[kk] = row[k];
      });
      return r;
    });

    // Detect lat/lon columns
    let hasLatLon = chkHasLatLon.checked;
    // Try to detect automatically if not checked
    if (!hasLatLon) {
      const sample = rows[0];
      const keysLower = Object.keys(sample).map(k => k.toLowerCase());
      const latKey = Object.keys(sample).find(k => ['lat','latitude','y'].includes(k.toLowerCase()));
      const lonKey = Object.keys(sample).find(k => ['lon','lng','longitude','x'].includes(k.toLowerCase()));
      if (latKey && lonKey) {
        hasLatLon = true;
        chkHasLatLon.checked = true;
      }
    }

    // If has lat/lon, map accordingly; else attempt geocoding using available address column(s)
    parsedRows = [];
    if (hasLatLon) {
      // Find keys for lat/lon
      const sample = rows[0];
      const latKey = Object.keys(sample).find(k => ['lat','latitude','y'].includes(k.toLowerCase())) || 'lat';
      const lonKey = Object.keys(sample).find(k => ['lon','lng','longitude','x'].includes(k.toLowerCase())) || 'lon';
      rows.forEach(r => {
        const out = {...r};
        out.lat = r[latKey] !== undefined ? r[latKey] : '';
        out.lon = r[lonKey] !== undefined ? r[lonKey] : '';
        parsedRows.push(out);
      });
    } else {
      // Need to find address column(s)
      // Strategy: if a column named 'address' or 'alamat' exists use it. Else try to combine common columns.
      const sample = rows[0];
      const keys = Object.keys(sample);
      let addrKey = keys.find(k => ['address','alamat','full address','full_address'].includes(k.toLowerCase()));
      if (!addrKey) {
        // try to combine common pieces
        const parts = [];
        ['street','jalan','street address','city','kota','province','provinsi','country','negara','district','kecamatan','village','desa','subdistrict'].forEach(p => {
          const found = keys.find(k => k.toLowerCase().includes(p));
          if (found && !parts.includes(found)) parts.push(found);
        });
        if (parts.length) {
          // build address for each row by concatenating parts
          for (const r of rows) {
            const addr = parts.map(k=>r[k]).filter(Boolean).join(', ');
            const out = {...r, address: addr};
            parsedRows.push(out);
          }
        } else {
          // fallback: take first column as address
          const firstKey = keys[0];
          for (const r of rows) {
            const out = {...r, address: r[firstKey]};
            parsedRows.push(out);
          }
        }
      } else {
        for (const r of rows) {
          const out = {...r, address: r[addrKey]};
          parsedRows.push(out);
        }
      }

      // Now geocode each row sequentially (to respect Nominatim rate-limits)
      for (let i=0;i<parsedRows.length;i++) {
        const row = parsedRows[i];
        if (row.address && (!row.lat || !row.lon)) {
          btnParse.textContent = `Geocoding ${i+1}/${parsedRows.length}…`;
          const result = await geocodeAddress(row.address);
          if (result) {
            row.lat = result.lat;
            row.lon = result.lon;
          } else {
            row.lat = '';
            row.lon = '';
          }
          // polite pause to avoid hammering service (1s)
          await new Promise(res => setTimeout(res, 1000));
        }
      }
    }

    // Display table and markers
    displayTable(parsedRows);
    addMarkers(parsedRows);

    // Enable downloads
    btnCSV.disabled = false;
    btnKML.disabled = false;

  } catch (e) {
    console.error(e);
    showError('Terjadi error saat memproses file. Lihat console untuk detail.');
  } finally {
    btnParse.disabled = false;
    btnParse.textContent = 'Parse & Tampilkan';
  }
});

btnCSV.addEventListener('click', () => {
  if (!parsedRows || !parsedRows.length) return;
  // Ensure lat/lon included; My Maps accepts CSV with columns including lat, lng (Google expects lat, lng columns or address)
  // We'll produce CSV with original fields plus lat,lon
  const rows = parsedRows.map(r => {
    // Ensure string keys
    const out = {...r};
    // prefer naming 'lat','lng' for Google My Maps
    out.lat = out.lat;
    out.lng = out.lon || out.lng;
    return out;
  });
  const csv = convertToCSV(rows);
  downloadFile('mymaps_export.csv', csv, 'text/csv;charset=utf-8;');
});

btnKML.addEventListener('click', () => {
  if (!parsedRows || !parsedRows.length) return;
  const kml = convertToKML(parsedRows, 'Excel export');
  downloadFile('mymaps_export.kml', kml, 'application/vnd.google-earth.kml+xml;charset=utf-8;');
});

/* OPTIONAL: If you want to use Google Geocoding instead of Nominatim:
   - Replace geocodeAddress function with one calling Google Geocoding API:
     const url = `https://maps.googleapis.com/maps/api/geocode/json?address=${q}&key=YOUR_API_KEY`;
   - Be mindful of quotas and billing.
*/

</script>
</body>
</html>
